/*
 * File: leg_conv.c
 *
 * MATLAB Coder version            : 5.5
 * C/C++ source code generated on  : 15-Sep-2025 13:09:38
 */

/* Include Files */
#include "bipedal_wheel_controller/vmc/leg_conv.h"
#include "bipedal_wheel_controller/vmc/leg_spd.h"
#include "bipedal_wheel_controller/vmc/leg_params.h"
#include <math.h>

/* Function Definitions */
/*
 * LEG_CONV
 *     T = LEG_CONV(F,Tp,PHI1,PHI2)
 *
 * Arguments    : double F
 *                double Tp
 *                double phi1
 *                double phi2
 *                double T[2]
 * Return Type  : void
 */
void leg_conv(double F, double Tp, double phi1, double phi4, double T[2])
{
  double t11_tmp;
  double t12_tmp;
  double t21;
  double t23;
  double t30_tmp;
  double t31;
  double t32_tmp;
  double t33;
  double t34;
  double t36_tmp;
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     2025-09-15 13:09:38 */
  t33 = phi1 + phi4;
  t11_tmp = cos(t33);
  t12_tmp = sin(t33);
  t21 = t11_tmp * 0.26;
  t23 = t12_tmp * 0.26;
  t30_tmp = t23 + sin(phi1) * 0.218;
  t31 = t30_tmp * t30_tmp;
  t32_tmp = t21 + cos(phi1) * 0.218;
  t33 = t32_tmp * t32_tmp;
  t34 = 1.0 / t33;
  t36_tmp = t31 + t33;
  t33 = Tp * t33 * (1.0 / t36_tmp);
  T[0] = t33 * (t31 * t34 + 1.0);
  T[1] = F * (t12_tmp * t32_tmp * 0.52 - t11_tmp * t30_tmp * 0.52) * -0.5 / sqrt(t36_tmp) +
         t33 * (t21 / t32_tmp + t30_tmp * t34 * t23);
}

// void leg_conv(double F, double Tp, double phi1, double phi4, double T[2])
//{
//   double t112;
//   double t114_tmp;
//   double t118_tmp;
//   double t130_tmp;
//   double t133_tmp;
//   double t141_tmp;
//   double t16_tmp;
//   double t184;
//   double t18_tmp;
//   double t33_tmp;
//   double t34_tmp;
//   double t35_tmp;
//   double t36_tmp;
//   double t49_tmp;
//   double t4_tmp;
//   double t50_tmp;
//   double t57_tmp;
//   double t58_tmp;
//   double t5_tmp;
//   double t64_tmp;
//   double t65_tmp;
//   double t66_tmp;
//   double t6_tmp;
//   double t7_tmp;
//   double t91_tmp;
//   /*     This function was generated by the Symbolic Math Toolbox version 23.2.
//    */
//   /*     2025-10-13 22:10:54 */
//   t4_tmp = cos(phi1);
//   t5_tmp = cos(phi4);
//   t6_tmp = sin(phi1);
//   t7_tmp = sin(phi4);
//   t16_tmp = t4_tmp * 0.218;
//   t18_tmp = t6_tmp * 0.218;
//   t33_tmp = t4_tmp * 0.11336;
//   t34_tmp = t5_tmp * 0.11336;
//   t35_tmp = t6_tmp * 0.11336;
//   t36_tmp = t7_tmp * 0.11336;
//   t49_tmp = t16_tmp - t5_tmp * 0.218;
//   t50_tmp = t18_tmp - t7_tmp * 0.218;
//   t57_tmp = t33_tmp - t34_tmp;
//   t58_tmp = t35_tmp - t36_tmp;
//   t184 = t6_tmp * t49_tmp * 0.436;
//   t64_tmp = t7_tmp * t49_tmp * 0.436;
//   t65_tmp = t4_tmp * t50_tmp * 0.436;
//   t66_tmp = t5_tmp * t50_tmp * 0.436;
//   t91_tmp = t49_tmp * t49_tmp + t50_tmp * t50_tmp;
//   t49_tmp = 1.0 / ((t34_tmp - t33_tmp) + t91_tmp);
//   t50_tmp = t49_tmp * t49_tmp;
//   t112 = sqrt((t57_tmp * t57_tmp + t58_tmp * t58_tmp) - t91_tmp * t91_tmp);
//   t114_tmp = 1.0 / t112;
//   t118_tmp = (t36_tmp - t35_tmp) + t112;
//   t130_tmp = atan(t49_tmp * t118_tmp) * 2.0;
//   t133_tmp = cos(t130_tmp);
//   t130_tmp = sin(t130_tmp);
//   t141_tmp = 1.0 / (t50_tmp * (t118_tmp * t118_tmp) + 1.0);
//   t112 = t50_tmp * ((t35_tmp + t65_tmp) - t184) * t118_tmp +
//          t49_tmp * (t33_tmp - t114_tmp *
//                                   ((t4_tmp * t58_tmp * 0.22672 -
//                                     t6_tmp * t57_tmp * 0.22672) +
//                                    t91_tmp * (t184 - t65_tmp) * 2.0) /
//                                   2.0);
//   t6_tmp = t50_tmp * ((t36_tmp + t66_tmp) - t64_tmp) * t118_tmp +
//            t49_tmp * (t34_tmp - t114_tmp *
//                                     ((t5_tmp * t58_tmp * 0.22672 -
//                                       t7_tmp * t57_tmp * 0.22672) +
//                                      t91_tmp * (t64_tmp - t66_tmp) * 2.0) /
//                                     2.0);
//   t33_tmp = t16_tmp + t133_tmp * 0.26;
//   t35_tmp = t18_tmp + t130_tmp * 0.26;
//   t114_tmp = t35_tmp * t35_tmp;
//   t184 = 1.0 / t35_tmp;
//   t118_tmp = t114_tmp + t33_tmp * t33_tmp;
//   t4_tmp = t130_tmp * t141_tmp;
//   t91_tmp = t18_tmp - t4_tmp * t112 * 0.52;
//   t130_tmp = t133_tmp * t141_tmp;
//   t50_tmp = t16_tmp - t130_tmp * t112 * 0.52;
//   t112 = F * (1.0 / sqrt(t118_tmp));
//   t49_tmp = Tp * t114_tmp * (1.0 / t118_tmp);
//   t118_tmp = t33_tmp * (1.0 / t114_tmp);
//   T[0] = t112 * (t35_tmp * t50_tmp * 2.0 - t33_tmp * t91_tmp * 2.0) / 2.0 +
//          t49_tmp * (t184 * t91_tmp + t118_tmp * t50_tmp);
//   T[1] = t112 *
//              (t130_tmp * t35_tmp * t6_tmp * 1.04 -
//               t4_tmp * t33_tmp * t6_tmp * 1.04) /
//              2.0 +
//          t49_tmp * (t184 * (t4_tmp * t6_tmp * 0.52) -
//                     t118_tmp * (0.0 - t130_tmp * t6_tmp * 0.52));
// }

// void leg_conv(double F, double Tp, double phi1, double phi4, double T[2])
//{
//   double J[2][2];
//   CalcJacobian(phi1, phi4, J);
//   // clang-format off
//     double JT[2][2] = {{J[0][0],J[1][0]}, // 转置矩阵
//                       {J[0][1],J[1][1]}};
//     double F_[2] = {F, Tp};
//   // clang-format on
//   double T1 = JT[0][0] * F_[0] + JT[0][1] * F_[1];
//   double T2 = JT[1][0] * F_[0] + JT[1][1] * F_[1];
//
//   T[0] = T1;
//   T[1] = T2;
// }

/*
 * File trailer for leg_conv.c
 *
 * [EOF]
 */
